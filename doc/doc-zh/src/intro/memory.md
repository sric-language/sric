

# 内存安全原理

Sric和Rust都是没有GC的内存安全语言，但两者有很大差别。Rust在编译时做安全检查，而Sric是在运行时检查内存安全。Rust的安全机制有很多编码限制，会强迫用户写复杂且低效的代码。Sric的安全机制是无感的，不需要做什么事就能获得内存安全。Sric的内存安全检查开销非常小，默认在Release模式下安全检查是关闭的，此时运行速度和手写C++代码一样快。

内存安全包括很多方面。数组越界、空指针、未初始化指针等，这些加简单的检查即可。因为使用所有权机制，也不存在内存泄漏、双重释放等问题。所以内存安全核心问题是怎么检测悬垂指针。Sric的非所有权指针负责主要的内存检测任务。

在Sric中非所有权指针是一个胖指针，它包括实际指针以及一个检测码等内容。对象内存内部也有一个相同的检测码。在创建指针的时候，指针的检测码和对象的检测码是一致的。当内存释放时，这个检测码被赋0。每次在使用指针时对比指针的检测码和对象的检测码是否相同，如果不同则说明对象内存已经释放掉了。这时候及时报错，不让错误传播到其他地方，这样很容易定位到问题。

虽然原理比较简单，但是需要考虑衍生指针怎么处理（指针指向内存中部，而不是内存头）、内存数组怎么处理、堆上分配和栈上分配怎么处理、非合作对象怎么处理（C++中定义的类没有地方存检测码）。幸运的是Sric已经把大部分问题都解决了。

Address Sanitizer也被用来做内存安全检测。但Address Sanitizer没法检测内存释放以后又被重新分配给其他对象的情况。Address Sanitizer的内存占用和运行开销也比较大。还有不能跨平台，第三方库需重新编译等问题。相比起来Sric检查的更全面，运行时开销非常小，没有平台限制。
